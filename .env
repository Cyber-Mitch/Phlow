MONGO_URI=mongodb://localhost:27017/Phlow
STARKNET_PROVIDER_URL=https://starknet-mainnet.infura.io/v3/YOUR_KEY
OFFRAMP_API_KEY=your_offramp_key
ENCRYPTION_KEY=32_byte_secure_key_here
AT_APIKEY=aatsk_350642f7612524615dc919a64cfb59260c87cc8705065fed6f7709f3db4c7634c56760ee
AT_USERNAME=Reentrancy
JWT_SECRET=your_jwt_secret
PORT=3000




So i'm building a crypto fiat ussd application, i will post all component of the current application, tell me what i need to complete it and how to run it,

db.js
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB connected');
  } catch (error) {
    console.error('Database connection error:', error);
    process.exit(1);
  }
};

module.exports = connectDB;

ratelimits.js
const rateLimit = require('express-rate-limit');

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests, please try again later.'
});

const ussdLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 50, // limit each IP to 50 requests per windowMs
  message: 'Too many USSD requests, please try again later.'
});

module.exports = { apiLimiter, ussdLimiter };

accountController.js
const User = require('../models/User');
const Account = require('../models/Account');
const { encrypt } = require('../middleware/security');

exports.addAccount = async (req, res) => {
  const { userId, accountNumber, bankCode } = req.body;

  try {
    const account = new Account({
      user: userId,
      accountToken: encrypt(accountNumber),
      metadata: {
        bankCode
      }
    });

    await account.save();

    // Link account to user
    await User.findByIdAndUpdate(userId, {
      $push: { withdrawalAccounts: account._id }
    });

    res.status(201).json({ message: 'Account added successfully', account });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

ussdController.js
const { handleMenuNavigation } = require('../services/ussdFlowManager');

exports.processUSSD = async (req, res) => {
  const { sessionId, phoneNumber, text } = req.body;
  
  try {
    const response = await handleMenuNavigation({
      sessionId,
      phoneNumber,
      input: text ? text.split('*') : []
    });
    
    res.set('Content-Type', 'text/plain');
    res.send(response);
  } catch (error) {
    res.send(`END Error: ${error.message}`);
  }
};

walletController.js
const User = require('../models/User');
const { encrypt } = require('../middleware/security');

exports.linkWallet = async (req, res) => {
  const { phoneNumber, privateKey, starknetAddress } = req.body;

  try {
    const user = await User.findOneAndUpdate(
      { phoneNumber },
      { encryptedKey: encrypt(privateKey), starknetAddress },
      { upsert: true, new: true }
    );

    res.status(200).json({ message: 'Wallet linked successfully', user });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

withdrawalController.js
const User = require('../models/User');
const { swapTokens, bridgeToEthereum } = require('../services/blockchain/starknet');
const WyreService = require('../services/offramp/wyre');
const wyre = new WyreService();

exports.initiateWithdrawal = async (req, res) => {
  const { userId, amount, accountId } = req.body;

  try {
    const user = await User.findById(userId).populate('withdrawalAccounts');
    const account = user.withdrawalAccounts.id(accountId);

    // Validate account
    const isValid = await wyre.validateAccount({
      accountToken: account.accountToken
    });

    if (!isValid) throw new Error('Invalid account details');

    // Execute withdrawal flow
    const swapTx = await swapTokens(user.encryptedKey, 'ETH', 'USDC', amount);
    const bridgeTx = await bridgeToEthereum(swapTx.hash);
    const fiatTx = await wyre.createTransfer(amount, account);

    res.status(200).json({
      swapTx: swapTx.hash,
      bridgeTx: bridgeTx.hash,
      fiatTx: fiatTx.id
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

auth.js
const jwt = require('jsonwebtoken');

const authenticate = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');

  if (!token) {
    return res.status(401).json({ error: 'Access denied. No token provided.' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(400).json({ error: 'Invalid token.' });
  }
};

module.exports = authenticate;

rateLimiter.js
const { apiLimiter, ussdLimiter } = require('../config/rateLimits');

module.exports = { apiLimiter, ussdLimiter };

security.js
const crypto = require('crypto');

const encrypt = (text) => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(process.env.ENCRYPTION_KEY), iv);
  let encrypted = cipher.update(text);
  encrypted = Buffer.concat([encrypted, cipher.final()]);
  return iv.toString('hex') + ':' + encrypted.toString('hex');
};

const decrypt = (text) => {
  const [iv, encrypted] = text.split(':').map(p => Buffer.from(p, 'hex'));
  const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(process.env.ENCRYPTION_KEY), iv);
  let decrypted = decipher.update(encrypted);
  decrypted = Buffer.concat([decrypted, decipher.final()]);
  return decrypted.toString();
};

module.exports = { encrypt, decrypt };

account.js
const mongoose = require('mongoose');
const { encrypt } = require('../middleware/security');

const accountSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  accountToken: { type: String, required: true },
  metadata: {
    bankName: String,
    last4Digits: String
  },
  verificationStatus: {
    type: String,
    enum: ['pending', 'verified'],
    default: 'pending'
  }
});

accountSchema.pre('save', function(next) {
  if (this.isModified('accountToken')) {
    this.accountToken = encrypt(this.accountToken);
  }
  next();
});

module.exports = mongoose.model('Account', accountSchema);

transaction.js
const mongoose = require('mongoose');

const transactionSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  type: { type: String, enum: ['conversion', 'withdrawal'], required: true },
  amount: { type: Number, required: true },
  status: { type: String, enum: ['pending', 'completed', 'failed'], default: 'pending' },
  txHash: String,
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Transaction', transactionSchema);

user.js
const mongoose = require('mongoose');
const { encrypt } = require('../middleware/security');

const userSchema = new mongoose.Schema({
  phoneNumber: { type: String, unique: true, required: true },
  encryptedKey: { type: String, required: true },
  starknetAddress: { type: String, required: true },
  bankAccount: {
    number: String,
    code: String
  },
  createdAt: { type: Date, default: Date.now }
});

userSchema.pre('save', function(next) {
  if (this.isModified('encryptedKey')) {
    this.encryptedKey = encrypt(this.encryptedKey);
  }
  next();
});

module.exports = mongoose.model('User', userSchema);

api.js
const express = require('express');
const router = express.Router();
const { apiLimiter } = require('../middleware/rateLimiter');
const { linkWallet } = require('../controllers/walletController');
const { initiateWithdrawal } = require('../controllers/withdrawalController');
const { addAccount } = require('../controllers/accountController');

router.post('/wallet/link', apiLimiter, linkWallet);
router.post('/withdraw', apiLimiter, initiateWithdrawal);
router.post('/account/add', apiLimiter, addAccount);

module.exports = router;

ussd.js
const express = require('express');
const router = express.Router();
const { ussdLimiter } = require('../middleware/rateLimiter');
const { processUSSD } = require('../controllers/ussdController');

router.post('/', ussdLimiter, processUSSD);

module.exports = router;

orbiter.js
const axios = require('axios');

// Orbiter Finance API configuration
const ORBITER_API_URL = 'https://testnet-api.orbiter.finance/sdk'; // Testnet URL
const ORBITER_API_KEY = 'YOUR_ORBITER_API_KEY'; // Replace with your Orbiter API key

/**
 * Bridge tokens from StarkNet to Ethereum using Orbiter Finance.
 * @param {string} txHash - The StarkNet transaction hash of the token transfer.
 * @param {string} recipient - The Ethereum address to receive the tokens.
 * @param {string} token - The token symbol (e.g., 'ETH', 'USDT', 'STRK').
 * @param {number} amount - The amount of tokens to bridge.
 * @returns {object} - The bridge transaction details.
 */
exports.bridgeToEthereum = async (txHash, recipient, token, amount) => {
  try {
    // Call Orbiter API to initiate the bridge
    const response = await axios.post(`${ORBITER_API_URL}/bridge`, {
      sourceChain: 'starknet',
      targetChain: 'ethereum',
      txHash,
      recipient,
      token,
      amount: amount.toString(),
    }, {
      headers: {
        'Authorization': `Bearer ${ORBITER_API_KEY}`,
        'Content-Type': 'application/json',
      },
    });

    return response.data;
  } catch (error) {
    console.error('Orbiter Bridge Error:', error.response ? error.response.data : error.message);
    throw new Error('Failed to initiate bridge transaction.');
  }
};

/**
 * Check the status of a bridge transaction.
 * @param {string} txHash - The transaction hash of the bridge transaction.
 * @returns {object} - The status of the bridge transaction.
 */
exports.checkBridgeStatus = async (txHash) => {
  try {
    const response = await axios.get(`${ORBITER_API_URL}/transaction/status/${txHash}`, {
      headers: {
        'Authorization': `Bearer ${ORBITER_API_KEY}`,
      },
    });

    return response.data;
  } catch (error) {
    console.error('Orbiter Status Check Error:', error.response ? error.response.data : error.message);
    throw new Error('Failed to check bridge transaction status.');
  }
};

starknet.js
const { Account, RpcProvider, Contract, uint256 } = require('starknet');

// Initialize StarkNet provider (Testnet)
const provider = new RpcProvider({ nodeUrl: 'https://starknet-testnet.infura.io/v3/YOUR_INFURA_KEY' });

// Token contract addresses (Testnet)
const TOKENS = {
  STARK: '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7', // ETH on StarkNet
  ETH: '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7', // ETH on StarkNet
  USDT: '0x068f5c6a61780768455de69077e07e89787839bf8166decfbf92b645209c0fb8', // USDT on StarkNet
};

// ERC20 ABI (simplified for balance and transfer)
const ERC20_ABI = [
  {
    name: 'balanceOf',
    type: 'function',
    inputs: [{ name: 'account', type: 'felt' }],
    outputs: [{ name: 'balance', type: 'Uint256' }],
  },
  {
    name: 'transfer',
    type: 'function',
    inputs: [
      { name: 'recipient', type: 'felt' },
      { name: 'amount', type: 'Uint256' },
    ],
    outputs: [],
  },
];

/**
 * Get the balance of a specific token for a given address.
 * @param {string} address - The StarkNet address to check the balance for.
 * @param {string} token - The token symbol (e.g., 'ETH', 'USDT', 'STRK').
 * @returns {string} - The token balance as a string.
 */
exports.getBalance = async (address, token) => {
  try {
    const contract = new Contract(ERC20_ABI, TOKENS[token], provider);
    const balance = await contract.balanceOf(address);
    return uint256.uint256ToBN(balance.balance).toString();
  } catch (error) {
    console.error(`Error fetching balance for ${token}:`, error);
    throw new Error(`Failed to fetch ${token} balance.`);
  }
};

/**
 * Transfer tokens from one StarkNet address to another.
 * @param {string} privateKey - The private key of the sender.
 * @param {string} fromAddress - The sender's StarkNet address.
 * @param {string} toAddress - The recipient's StarkNet address.
 * @param {string} token - The token symbol (e.g., 'ETH', 'USDT', 'STRK').
 * @param {number} amount - The amount of tokens to transfer.
 * @returns {string} - The transaction hash.
 */
exports.transferTokens = async (privateKey, fromAddress, toAddress, token, amount) => {
  try {
    const account = new Account(provider, fromAddress, privateKey);
    const contract = new Contract(ERC20_ABI, TOKENS[token], account);

    // Convert amount to Uint256 format
    const amountUint256 = uint256.bnToUint256(amount);

    // Execute the transfer transaction
    const tx = await contract.transfer(toAddress, amountUint256);
    await provider.waitForTransaction(tx.transaction_hash);

    return tx.transaction_hash;
  } catch (error) {
    console.error(`Error transferring ${token}:`, error);
    throw new Error(`Failed to transfer ${token}.`);
  }
};

ussdflow manger.js
const User = require('../models/User');
const Transaction = require('../models/Transaction');
const { getBalance, transferTokens } = require('./blockchain/starknet');
const { bridgeToEthereum } = require('./blockchain/orbiter');
const { convertToFiat } = require('./offramp/wyre');

exports.handleMenuNavigation = async ({ sessionId, phoneNumber, input }) => {
  try {
    const user = await User.findOne({ phoneNumber });
    const [step, ...values] = input;

    switch (step) {
      case undefined: // Initial menu
        return `CON Welcome to Plow!
        1. Connect Wallet
        2. Check Balance
        3. Convert Crypto to Cash
        4. Transaction History
        5. Change Bank Account`;

      case '1': // Connect Wallet
        if (!values[0]) return 'CON Enter your StarkNet wallet private key:';
        if (!values[1]) return 'CON Enter your StarkNet address:';
        
        await User.findOneAndUpdate(
          { phoneNumber },
          { encryptedKey: values[0], starknetAddress: values[1] },
          { upsert: true }
        );
        return 'END Wallet connected successfully!';

      case '2': // Check Balance
        if (!user) return 'END Wallet not connected. Use option 1 to connect.';
        const balance = await getBalance(user.starknetAddress, 'ETH');
        return `END Your balance: ${balance} ETH`;

      case '3': // Convert Crypto to Cash
        if (!user) return 'END Wallet not connected. Use option 1 to connect.';
        if (!values[0]) return `CON Select token:
        1. STRK
        2. ETH
        3. USDT`;

        const tokenOption = values[0];
        let token;
        switch (tokenOption) {
          case '1':
            token = 'STRK';
            break;
          case '2':
            token = 'ETH';
            break;
          case '3':
            token = 'USDT';
            break;
          default:
            return 'END Invalid token selected.';
        }

        if (!values[1]) return `CON Enter amount to convert (in ${token}):`;
        if (!values[2]) return 'CON Enter your bank account number:';

        const amount = parseFloat(values[1]);
        const accountNumber = values[2];

        // Step 1: Transfer tokens to Orbiter's StarkNet address
        const orbiterStarknetAddress = '0xOrbiterStarknetAddress'; // Replace with Orbiter's StarkNet address
        const txHash = await transferTokens(user.encryptedKey, user.starknetAddress, orbiterStarknetAddress, token, amount);

        // Step 2: Initiate bridge to Ethereum using Orbiter
        const bridgeResult = await bridgeToEthereum(txHash, accountNumber, token, amount);

        // Step 3: Convert bridged tokens to fiat using Wyre
        const fiatTx = await convertToFiat(bridgeResult.recipient, amount, accountNumber);

        // Save transaction to database
        await Transaction.create({
          user: user._id,
          type: 'conversion',
          token,
          amount,
          status: 'completed',
          txHash: fiatTx.id
        });

        return `END Conversion successful! Fiat TX ID: ${fiatTx.id}`;

      case '4': // Transaction History
        if (!user) return 'END Wallet not connected. Use option 1 to connect.';
        const transactions = await Transaction.find({ user: user._id }).sort({ createdAt: -1 }).limit(5);
        if (transactions.length === 0) return 'END No transactions found.';

        let history = 'END Recent Transactions:\n';
        transactions.forEach((tx, index) => {
          history += `${index + 1}. ${tx.type} - ${tx.amount} ${tx.token} - ${tx.status}\n`;
        });
        return history;

      case '5': // Change Bank Account
        if (!user) return 'END Wallet not connected. Use option 1 to connect.';
        if (!values[0]) return 'CON Enter new bank account number:';
        if (!values[1]) return 'CON Enter bank code:';

        await User.findOneAndUpdate(
          { phoneNumber },
          { bankAccount: { number: values[0], code: values[1] } }
        );
        return 'END Bank account updated successfully!';

      default:
        return 'END Invalid option. Please try again.';
    }
  } catch (error) {
    console.error(`Error in session ${sessionId}:`, error);
    return 'END An error occurred. Please try again later.';
  }
};

https://docs.orbiter.finance/developer/js-sdk
https://docs.orbiter.finance/developer/rest-api/api-collection
https://starknetjs.com/docs/API/
https://starknetjs.com/docs/guides/intro

so work flow is