import { VMType } from '@orbiter-finance/vm-core';

interface ConfigOptions {
    apiEndpoint: ENDPOINT;
    dealerId?: string;
    apiKey?: string;
    channelId?: string;
    defaultRouterType?: RouterType;
}
declare enum ENDPOINT {
    TESTNET = "https://testnet-api.orbiter.finance/sdk",
    MAINNET = "https://api.orbiter.finance/sdk"
}
declare enum CDNENDPOINT {
    TESTNET = "https://testnet-cdn.orbiter.finance/config",
    MAINNET = "https://cdn.orbiter.finance/config"
}
interface TradePair {
    srcChainId: string;
    dstChainId: string;
    srcTokenSymbol: string;
    dstTokenSymbol: string;
    routerType?: RouterType;
}
declare enum RouterType {
    EOA = "EOA",
    CONTRACT = "CONTRACT"
}
interface Chain {
    id: string;
    name: string;
}
interface TransactionParams {
    srcAddress: string;
    dstAddress: string;
    value: string;
    amount: string;
    raw: unknown;
}
interface ApproveParams {
    ownerAddress: string;
    spenderAddress: string;
    value: string;
    amount: string;
    raw: unknown;
}

interface APIResponse<T> {
    status: string;
    message: string;
    result: T;
}
interface ChainConfig {
    chainId: string;
    networkId: string;
    internalId: number;
    name: string;
    nativeCurrency: Token;
    tokens: Token[];
    contracts: Contract[];
    vm: VMType;
}
interface Token {
    name: string;
    symbol: string;
    decimals: number;
    coinKey: string;
    address: string;
    isNative?: boolean;
}
interface Contract {
    name: string;
    address: string;
}
interface RouterConfig {
    line: string;
    endpoint: string;
    endpointContract?: string;
    srcChain: string;
    tgtChain: string;
    srcToken: string;
    tgtToken: string;
    maxAmt: string;
    minAmt: string;
    tradeFee: string;
    withholdingFee: string;
    vc: string;
    state: RouterState;
    compRatio: number;
    spentTime: number;
    tieredFee: TieredFee[];
}
interface TieredFee {
    range: [number, number];
    tradeFee: number;
    withholdingFee: number;
}
declare enum RouterState {
    AVAILABLE = "available",
    DISABLED = "disabled"
}
interface Transaction {
    sourceId: string;
    targetId: string;
    sourceChain: string;
    targetChain: string;
    sourceAmount: string;
    sourceMaker: string;
    sourceAddress: string;
    targetAddress: string;
    sourceSymbol: string;
    targetSymbol: string;
    status: number;
    sourceTime: string;
    targetTime: string;
    points?: string;
}
interface PointRule {
    [chain: string]: {
        [symbol: string]: string;
    };
}

declare class ApiService {
    private apiEndpoint;
    private cdnEndpoint;
    private apiKey?;
    private channelId?;
    constructor(apiEndpoint: ENDPOINT, apiKey?: string, channelId?: string);
    private fetchAPIGet;
    private fetchCDNGet;
    getChainList(): Promise<ChainConfig[]>;
    getTokenList(): Promise<Record<string, Token[]>>;
    getRouterList(dealerId?: string): Promise<RouterConfig[]>;
    getBasePointRules(): Promise<PointRule>;
    getSimulatedReceiveAmount(line: string, value: string, nonce?: string, dealer?: string, brokerageTradeFeeRate?: number): Promise<{
        receiveAmount: string;
        router: RouterConfig;
    }>;
    getTransactionHistory(address: string, offset?: number): Promise<any>;
    getTransactionStatus(hash: string): Promise<any>;
    getUserOpoint(address: string): Promise<any>;
}

declare class ConfigService {
    readonly apiKey?: string;
    readonly dealerId?: string;
    readonly channelId?: string;
    private readonly _apiService;
    private _chainConfigs?;
    private _routerConfigs?;
    private _basePointRules?;
    private _tokens?;
    constructor(apiService: ApiService);
    initConfig(): Promise<void>;
    getRouterConfigs(): RouterConfig[];
    getRouterConfig(tradePair: TradePair): RouterConfig | undefined;
    getChainConfigs(): ChainConfig[];
    getChainConfigByName(chainName: string): ChainConfig | undefined;
    getChainConfigById(chainId: string): ChainConfig | undefined;
    getBasePointRule(chainId: string, symbol: string): string;
}

declare class VMService {
    private readonly _configService;
    constructor(configService: ConfigService);
    isValidTransferType(routerType: RouterType): boolean;
    createTransaction(srcAddress: string, srcToken: Token, dstAddress: string, dstToken: Token, value: string, vc: string, routerType: RouterType, makerAddress: string, chainId: string, contractAddress?: string, channelId?: string): Promise<TransactionParams>;
    createApprove(ownerAddress: string, spenderAddress: string, approveToken: Token, chainId: string, value: string): Promise<ApproveParams>;
    createAllowance(ownerAddress: string, spenderAddress: string, approveToken: Token, chainId: string): Promise<unknown>;
}

declare class Router {
    readonly srcChainConfig: ChainConfig;
    readonly srcToken: Token;
    readonly dstChainConfig: ChainConfig;
    readonly dstToken: Token;
    readonly basePoint: string;
    private readonly _VMService;
    readonly routerConfig: RouterConfig;
    readonly routerType: RouterType;
    private readonly _channelId?;
    constructor(srcChainConfig: ChainConfig, srcToken: Token, dstChainConfig: ChainConfig, dstToken: Token, basePoint: string, _VMService: VMService, routerConfig: RouterConfig, routerType: RouterType, _channelId?: string | undefined);
    get routerId(): string;
    get vc(): string;
    get withholdingFee(): string;
    get tradeFee(): string;
    get makerAddress(): string;
    get contractAddress(): string | undefined;
    get spentTime(): number;
    private _getAmountWithVc;
    createTransaction(srcAddress: string, dstAddress: string, amount: string): Promise<TransactionParams>;
    createApprove(ownerAddress: string, amount: string): Promise<ApproveParams>;
    createAllowance(ownerAddress: string): Promise<unknown>;
    getMinSendAmountMinusWithHoldingFee(): string;
    getMinSendAmount(): string;
    getMaxSendAmount(): string;
    simulationAmountPlusWithHoldingFee(amount: string): {
        sendAmount: string;
        receiveAmount: string;
    };
    simulationAmount(amount: string): {
        sendAmount: string;
        receiveAmount: string;
    };
    private _getResponseIntent;
    private _getTargetAmountSafeLengthByToken;
}

declare class OrbiterClient {
    private readonly _config;
    private readonly _apiService;
    private readonly _configService;
    private readonly _VMServiceFactory;
    private readonly _defaultRouterType;
    constructor(config: ConfigOptions);
    init(): Promise<void>;
    static create(config: ConfigOptions): Promise<OrbiterClient>;
    createRouter(tradePair: TradePair): Router;
    private checkTradePairType;
    getAllChains(): Chain[];
    getAllSymbols(): string[];
    getChainConfig(chainId: string): ChainConfig | undefined;
    getAvailableTokens(chainId: string): Token[];
    getAllTradePairs(): TradePair[];
    getAvailableTradePairs(srcChainId?: string, srcTokenSymbol?: string): TradePair[];
    getTransactionHistory(address: string, offset?: number): Promise<{
        count: number;
        rows: Transaction[];
        offset: number;
        limit: number;
    }>;
    getTransactionStatus(hash: string, chainId?: string): Promise<{
        chainId: string;
        hash: string;
        sender: string;
        receiver: string;
        amount: string;
        symbol: string;
        timestamp: string;
        status: number;
        opStatus: number;
        targetId: string;
        targetAmount: string;
        targetSymbol: string;
        targetChain: string;
    }>;
    getUserOpoint(address: string): Promise<{
        address: string;
        summary: {
            [key: string]: number;
        };
        points: number;
    }>;
}

export { type APIResponse, ApiService, type ApproveParams, CDNENDPOINT, type Chain, type ChainConfig, type ConfigOptions, type Contract, ENDPOINT, OrbiterClient, type PointRule, Router, type RouterConfig, RouterState, RouterType, type TieredFee, type Token, type TradePair, type Transaction, type TransactionParams };
